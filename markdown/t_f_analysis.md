# 如何对数据进行时频分析

在许多信号处理问题中，我们关心的不仅是“信号里有哪些频率成分”，还关心“这些频率成分在什么时候出现、持续多久、如何演化”。如果一个信号在整个观测时间内统计特性近似不变，我们往往可以把它视为平稳或近似平稳信号，此时经典的傅里叶分析非常有效：它把信号分解为一组固定频率的正弦/余弦（或复指数）叠加，从而给出清晰的全局频谱。然而，真实世界里更常见的是非平稳信号：语音的音素随时间变化，机械振动的故障特征可能在某一时刻突然出现，雷达/声纳回波可能包含短暂的调制结构，引力波探测中的啁啾信号更是以频率随时间上升为核心特征。对这类信号，仅有“全局频谱”往往是不够的，因为它会把时间信息完全平均掉：你可以知道某些频率存在，却不知道它们出现的时间位置与变化轨迹。

时频分析的核心目标，正是为了解决“时间—频率联合表征”的需求。它试图构造一种表示，使得我们能够同时读出信号在不同时间附近的频率内容，从而揭示信号的瞬态、调制、频率漂移、突变等结构。直观地说，时频分析就是在问：在时间轴的某一小段窗口里，信号更像哪些频率成分？当我们把这个问题沿时间滑动，并把每一时刻（或每一窗口中心）的“局部频谱”排列起来，就得到一张二维图：横轴是时间，纵轴是频率，颜色或灰度表示该时间—频率位置上的能量/幅值强度。这张二维表示就称为时频图（time–frequency representation），在工程语境中常见的可视化形式是谱图（spectrogram），在更一般的理论框架下还包括多种不同定义的时频分布。

需要强调的是，时频图并不是“把傅里叶变换画成二维”的简单操作，而是源于一个本质的权衡：时间分辨率与频率分辨率无法同时无限提高。原因可以从不确定性思想理解：为了得到某一时刻附近的频谱，你必须截取或加权一个时间窗口；窗口越短，你对“什么时候发生”的定位越准确，但由于观察时间变短，你对“频率是多少”的辨别能力会下降；窗口越长则相反。这种权衡在很多时频方法中以不同形式出现，并且直接决定了时频图上结构的清晰度与可解释性。也正因为存在权衡，时频分析不是单一算法，而是一组方法论：针对不同信号形态与任务目标，选择合适的时频表示、窗口/尺度策略、以及后续的估计与检测方法，才是得到可靠结论的关键。

从应用角度看，时频图的价值在于它把“信号随时间变化的频谱结构”可视化并量化。对于啁啾信号，时频图上常出现一条随时间上升（或下降）的能量脊线；对于含有冲击或短暂故障的振动信号，时频图上会出现局部的宽频瞬态；对于幅度调制或频率调制信号，时频图能够呈现边带、频率摆动或调制纹理。更重要的是，时频图不仅用于“看图”，它还常被用作进一步处理的中间表示，例如从时频平面提取脊线来估计瞬时频率，从局部能量来做事件检测与分割，或将时频图输入机器学习模型进行分类与识别。因此，时频分析既是一种解释工具，也是一种特征提取与推断框架。

## 1 方法原理

时频分析的核心任务，是在“时间局部”与“频率局部”这两个彼此制约的目标之间取得可控的折中：我们希望知道信号在某一时刻附近主要包含哪些频率成分，以及这些成分如何随时间演化。对非平稳信号而言，传统傅里叶变换把全时域信息压缩到单一频谱中，会不可避免地丢失“何时出现某频率”的信息；因此时频方法的共同思想，是用一族同时具有时间与频率局部性的“分析原子”去与信号做内积，从而得到随时间变化的谱结构。下面以短时傅里叶变换（STFT）与连续小波变换（CWT）为主线，并补充 Hilbert 变换相关的瞬时量方法。

STFT 可以看作“在滑动窗口内做傅里叶变换”。给定信号 $x(t)$ 与窗函数 $w(t)$，其连续形式通常写为

$$
X(t,\omega)=\int_{-\infty}^{\infty} x(\tau)\, w(\tau-t)\, e^{-j\omega \tau}\, d\tau .
$$

这里 $t$ 表示窗口中心的时间位置，$\omega$ 是角频率。直观上，$w(\tau-t)$ 把信号截取到 $t$ 附近的一段局部区间，在这个局部区间内信号被“近似看作平稳”，从而可以用傅里叶基函数 $e^{j\omega \tau}$ 来描述其局部频谱。时频图最常用的能量表征是谱图（spectrogram）：

$$
S(t,\omega)=\left|X(t,\omega)\right|^2,
$$

它在很多应用中被理解为“信号能量随时间—频率的分布”，也便于直接可视化。

STFT 的关键在于窗函数的选择及其长度（或等效带宽）。窗口越短，时间定位越精确，但频率分辨率变差；窗口越长，频率分辨率提高，但时间定位变差。这一折中可用不确定性原理（Heisenberg–Gabor 不确定性）作定性刻画：窗函数在时域越集中，其频域扩展越宽，导致 $\Delta t\,\Delta \omega$ 存在下界。因此，STFT 的一个本质特征是“固定分辨率”：在所有频率处都使用同样时间尺度的窗进行分析。这使得它对某些信号（例如频带范围相对有限、或在各频段需要同等时间分辨率的场景）较为合适，但对同时包含慢变低频与快速高频瞬变的信号，往往难以用单一窗长兼顾。

从“投影”的角度看，STFT 实际上是在一族由窗口与调制构成的原子上做内积：

$$
g_{t,\omega}(\tau)=w(\tau-t)e^{j\omega \tau},\quad X(t,\omega)=\langle x, g_{t,\omega}\rangle .
$$

这种结构也直接引出离散实现中的重叠分帧、窗函数旁瓣泄漏、以及重构条件（如适当选择窗与步长可实现 overlap-add 重构）。这些实现层面的细节在后续章节讨论数值计算与参数选择时会用到。

与 STFT 用“固定窗长的正弦基”不同，CWT 用“可伸缩、可平移的小波”来适配信号的多尺度特征。给定母小波 $\psi(t)$，CWT 定义为

$$
W_x(a,b)=\frac{1}{\sqrt{|a|}}\int_{-\infty}^{\infty} x(t)\,\psi^*\!\left(\frac{t-b}{a}\right)\, dt ,
$$

其中 $b$ 是时间平移参数，$a$ 是尺度（scale）参数，$^*$ 表示复共轭。尺度 $a$ 控制小波的伸缩：$a$ 越小，小波在时域越“短”、对应更高的分析频率；$a$ 越大，小波在时域越“长”、对应更低的分析频率。因而 CWT 天然具有“可变分辨率”：高频处获得更好的时间分辨率，低频处获得更好的频率分辨率。这一点与许多自然信号（语音、地震、机械故障振动等）的结构更匹配：高频往往以瞬态形式出现，而低频变化更慢、更需要精细的频率刻画。

为了保证小波能进行无偏的多尺度分析并可逆，母小波需要满足可容许性（admissibility）条件，其典型形式为

$$
C_\psi=\int_{0}^{\infty}\frac{|\Psi(\omega)|^2}{\omega}\, d\omega <\infty ,
$$

其中 $\Psi(\omega)$ 为 $\psi(t)$ 的傅里叶变换。该条件的一个重要含义是 $\Psi(0)=0$，等价于 $\int \psi(t)\,dt=0$，即小波具有零均值，能够“过滤掉”直流分量，从而强调变化与局部结构。满足该条件时，存在逆变换公式在适当意义下重构信号：

$$
x(t)=\frac{1}{C_\psi}\int_{0}^{\infty}\int_{-\infty}^{\infty} W_x(a,b)\,\frac{1}{a^{3/2}}\psi\!\left(\frac{t-b}{a}\right)\, db\, da .
$$

在可视化上，CWT 常用标度图（scalogram）$|W_x(a,b)|^2$ 表示能量随“时间—尺度”的分布；为了更接近“时间—频率”的直觉，常将尺度 $a$ 映射为伪频率（pseudo-frequency）。若母小波的中心频率为 $f_c$，采样周期为 $\Delta t$，则常用近似关系

$$
f \approx \frac{f_c}{a\,\Delta t},
$$

从而将 CWT 结果解释为随时间变化的频谱结构。需要强调的是：该映射依赖于所选小波（例如 Morlet 小波因其窄带特性更便于频率解释），因此在使用 CWT 时，母小波的选型不仅影响分辨率形态，也影响尺度—频率对应的物理可解释性。

在方法论层面，CWT 也可理解为对一族“小波原子”做内积：

$$
\psi_{a,b}(t)=\frac{1}{\sqrt{|a|}}\psi\!\left(\frac{t-b}{a}\right),\quad W_x(a,b)=\langle x,\psi_{a,b}\rangle .
$$

与 STFT 的差异在于：STFT 的原子是固定窗长下的纯正弦调制，而 CWT 的原子同时具备伸缩与平移，从而形成更贴合多尺度信号的分析框架。

除“投影型”的时频分解外，还有一类方法强调从信号本身构造“瞬时幅值”和“瞬时频率”，Hilbert 变换是其中的核心工具。Hilbert 变换定义为

$$
\mathcal{H}\{x\}(t)=\frac{1}{\pi}\,\mathrm{p.v.}\int_{-\infty}^{\infty}\frac{x(\tau)}{t-\tau}\, d\tau ,
$$

其中 $\mathrm{p.v.}$ 表示柯西主值。由此可构造解析信号（analytic signal）

$$
z(t)=x(t)+j\,\mathcal{H}\{x\}(t)=A(t)e^{j\phi(t)},
$$

进而得到瞬时幅值 $A(t)=|z(t)|$ 与瞬时相位 $\phi(t)=\arg z(t)$。瞬时频率通常定义为

$$
\omega_i(t)=\frac{d\phi(t)}{dt},\qquad f_i(t)=\frac{1}{2\pi}\frac{d\phi(t)}{dt}.
$$

从解释上讲，Hilbert 变换通过构造与原信号正交的“虚部”，把实信号提升到复平面，使其相位随时间的变化成为可微对象，从而定义局部的频率变化。这种思路与 STFT/CWT 的“局部投影”不同：它不是在预设基函数族上展开，而是试图直接从信号的局部相位演化提取频率。

不过，瞬时频率的合理性有明确前提：信号应当在局部近似为单分量、窄带（或至少具有良好的“单一瞬时相位”结构）。当信号含有多个相互叠加的振荡成分时，解析信号的相位可能出现交叉、突变或非物理的频率摆动，使得 $\omega_i(t)$ 对噪声与多分量叠加非常敏感。工程上常见的做法是先进行带通滤波、或先做自适应分解（例如经验模态分解 EMD 得到若干 IMF 分量），再对各分量分别做 Hilbert 变换并汇总为 Hilbert 频谱；这类组合方法强调“先分量化、再瞬时化”，本质上是为满足瞬时频率的适用条件而设计。

综上，STFT 提供了概念与实现都相对直接的“固定分辨率”时频表示，参数主要由窗函数与窗长决定；CWT 通过尺度伸缩实现“可变分辨率”的多尺度分析，更适合跨频段结构差异显著的非平稳信号；Hilbert 变换法则侧重于通过解析信号定义瞬时幅值与瞬时频率，若信号满足单分量/窄带假设（或经预处理后满足），可以给出非常细粒度的频率随时间演化刻画。后续章节在讨论参数选择、分辨率分析、离散实现与典型示例时，可以把这三类方法视作从“局部投影—多尺度投影—瞬时相位”三个角度对同一问题的不同建模与表征。

## 2 编程实现

> STFT 可以调用 SciPy 的接口，具体是 [`scipy.signal.ShortTimeFFT`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT)，详解使用文档。

> CWT 可以调用 PyWavelets 的接口，具体是 [`pywt.cwt(data, scales, wavelet, sampling_period=1.0, method='conv', axis=-1, *, precision=12)`](https://pywavelets.readthedocs.io/en/latest/ref/cwt.html)，详见使用文档。

时频分析的工程实现通常围绕两类变换展开：一类是以离散短时傅里叶变换（STFT）为代表的“固定窗长、固定频率分辨率”方法，另一类是以连续小波变换（CWT）为代表的“尺度自适应、近似常数相对带宽（constant-Q）”方法。SciPy 与 PyWavelets 分别提供了面向工程使用的高层封装：`scipy.signal.ShortTimeFFT` 将 STFT/ISTFT 的参数化、可逆性与边界处理组织为一个对象；`pywt.cwt` 则以尺度集合为自变量给出 CWT 系数，并配套尺度—频率转换工具，便于在物理频率轴上解释结果。

### 2.1 SciPy：`scipy.signal.ShortTimeFFT` 的面向对象 STFT/ISTFT

`ShortTimeFFT(win, hop, fs, *, fft_mode='onesided', mfft=None, dual_win=None, scale_to=None, phase_shift=0)` 的核心思想是：将“窗函数、滑移步长、采样率、FFT 方式、零填充长度、对偶窗与幅度标定”等关键要素一次性固化为对象属性，从而在后续计算中以一致的时间—频率网格解释结果。STFT 的输出可视为复数矩阵 $S[q,p]$，其中时间索引 $p$ 对应窗函数中心位于 $t[p]=p\Delta t$，$\Delta t=\text{hop}\cdot T$，$T=1/fs$；频率索引 $q$ 对应 $f[q]=q\Delta f$，$\Delta f=1/(mfft\cdot T)$。这套网格由对象的 `delta_t`、`delta_f`、`f` 等属性直接给出，使得每一列谱切片在物理意义上与时间中心严格对齐。

窗函数 `win` 是一维数组，可为实或复；`hop` 以样点数定义相邻窗的滑移；`mfft` 决定 FFT 长度，若大于窗长则等价于零填充，从而实现更密的频率采样（更小的 $\Delta f$），但不改变本质分辨率。`fft_mode` 控制频谱表示方式：常见的 `onesided` 适用于实信号并返回非负频率；`twosided` 则保留正负频率。`scale_to` 在工程可视化中非常关键：当取 `'magnitude'` 或 `'psd'` 时，SciPy 会对窗函数做相应归一化，使得每一列更接近“幅度谱”或“功率谱密度”的物理量表述；相应标定因子可由 `fac_magnitude`、`fac_psd` 查看。`phase_shift` 用于对每个频率点叠加线性相位，默认 0 代表在 $t=0$ 所在切片不引入额外相位偏移，便于在某些对齐约定下保持相位一致性。

STFT 的计算通过 `stft(x, ...)` 完成；若需要在每个窗段上先去趋势，可使用 `stft_detrend(x, detr=...)`。边界效应是 STFT 工程应用的常见来源：由于 $t=0$ 约定对应输入信号的第一个样点，窗函数在起始处无法居中覆盖信号，导致 STFT 的时间切片可能出现在信号支撑之外，因此对象会出现“负时间槽”。这也是 `p_min`、`k_min` 等属性语义不同于 NumPy 负索引的原因：负的 $p$ 表示位于 $t=0$ 左侧，而非从数组尾部反向计数。绘图时常用 `extent(n)` 直接得到与 `imshow`/`pcolormesh` 兼容的 $[t_{\min},t_{\max},f_{\min},f_{\max}]$ 范围，并可结合 `lower_border_end` 与 `upper_border_begin(n)` 标出“窗未完全落入信号区间”的边界带，从而将谱图中的边缘伪影与主体区域区分开。

逆变换通过 `istft(S, ...)` 完成，其实现路径与理论一致：对每一列谱做 IFFT 得到窗段时域片段，乘以对偶窗 `dual_win`，再按 $p\Delta t$ 平移并叠加重构。`ShortTimeFFT` 默认在需要时计算“规范对偶窗”（能量最小的对偶窗），并以 `invertible` 标记当前参数化是否可逆；在需要控制对偶窗形状或数值性质时，可显式传入 `dual_win`，或使用 `from_dual`、`from_win_equals_dual` 等构造方式。实际重构时经常需要显式指定输出长度，例如 `istft(..., k1=n)`，原因在于 STFT 的切片位置以 hop 为步进，含边界延拓时重构向量长度并不天然等于原始长度。

`ShortTimeFFT` 还支持对信号分段计算并在频域拼接：`p_num(n)`、`p_range`、`nearest_k_p` 等方法提供了“样点索引—切片索引”的一致映射；在拼接相邻分段 STFT 时，重叠区域需要以相同切片相加的方式合成，才能与对整段信号一次性计算的 STFT 保持一致。相同思想也适用于对 `istft` 的区间重构：传入切片范围即可重构对应的时域片段，常用于局部去噪或局部滤波后的回放验证。

### 2.2 PyWavelets：`pywt.cwt` 的连续小波变换接口

`pywt.cwt(data, scales, wavelet, sampling_period=1.0, method='conv', axis=-1, *, precision=12)` 以“尺度集合”作为主输入，返回系数矩阵 `coefs` 与物理频率数组 `frequencies`。在一维情况下，`coefs` 的第 0 轴对应尺度（从而对应频率），其余维度与输入信号形状一致。`sampling_period` 用于将尺度映射为 Hz：频率可由 `f = scale2frequency(wavelet, scale) / sampling_period` 理解；当采样周期以秒为单位时，输出 `frequencies` 也具有 Hz 量纲。需要强调的是，系数本身由卷积计算得到，对 `sampling_period` 的选择不敏感；`sampling_period` 主要影响频率标注与尺度解释。

计算方式 `method` 典型取 `'conv'` 或 `'fft'`：前者等价于时域卷积，复杂度随尺度长度线性增长；后者通过频域卷积，适合长序列与大尺度集合。`precision` 决定用于离散化小波的支持长度（约为 $2^{\text{precision}}$），过低会导致高频尺度处滤波核采样不足，从而出现系数与范数的畸变（工程上常见为“拉链状”伪影）；因此通常将 `precision` 取不小于 12，以换取更稳定的系数质量。

尺度选择是 CWT 使用中的核心环节。更大的尺度对应更宽的小波、对更低频更敏感；更小的尺度对应更窄的小波、对更高频更敏感。PyWavelets 提供 `scale2frequency` 与 `frequency2scale` 两个互逆工具，支持在“尺度域指定”与“物理频率域指定”之间切换。对于 `cmor`、`fbsp`、`shan` 等可参数化中心频率的连续小波，还可以通过字符串形式将带宽与中心频率写入标识符（例如 `cmorB-C`），从而在时间—频率分辨率之间做可控权衡。若使用复小波（如复 Morlet），`coefs` 为复数，谱图展示时常取模值 $|\text{coefs}|$ 或功率 $|\text{coefs}|^2$，并可配合对数频率轴更贴近人类感知或宽带信号的结构展示。需要留意的是，PyWavelets 的 CWT 实现在一些场景存在已知问题，表现为速度或精度的局限；在高性能或高精度场景下通常需要额外的数值验证。

## 3 参数设置

在工程场景中，$\Delta f$ 常被用作“频率轴离散化尺度”的统一控制量：一方面决定谱图（或尺度图）沿频率方向的采样密度，另一方面也隐含对“可分辨频率间隔”的期望。然而需要区分两个概念：其一是离散网格的**频率采样间隔**（bin spacing），其二是分析核（窗函数或小波）在频域的**有效带宽**（决定实际分辨率与泄漏）。上述实现方案的关键在于：先把 $\Delta f$ 解释为希望得到的频率网格间隔，再将窗函数长度或小波带宽参数与之绑定，使网格间隔与分析核带宽在量级上匹配，从而避免明显的过采样或欠采样。

### 3.1 STFT 中 $\Delta f$ 的设定原理：由 FFT 点数得到频率网格

对离散 STFT 而言，`ShortTimeFFT` 的频率采样间隔由

$$
\Delta f_{\text{STFT}}=\frac{1}{m_{\text{fft}}\,T}=\frac{F_s}{m_{\text{fft}}}
$$

给出，其中 $T=1/F_s$ 为采样间隔，$m_{\text{fft}}$ 为 FFT 长度。若不显式指定 `mfft`，SciPy 默认取 `mfft = len(win) = m_win`，于是

$$
\Delta f_{\text{STFT}}\approx \frac{F_s}{m_{\text{win}}}.
$$

实现中采用

$$
m_{\text{win}}=\left\lfloor \frac{F_s}{\Delta f}\right\rfloor
$$

（代码为 `m_win = int(Fs / Df)`），代入即得到

$$
\Delta f_{\text{STFT}}\approx \frac{F_s}{F_s/\Delta f}=\Delta f,
$$

从而把期望的频率网格间隔 $\Delta f$ 直接落在 STFT 的频率 bin 间隔上。此处的 $\Delta f_{\text{STFT}}$ 是“相邻频率点的采样间距”，并非严格意义上的“可分辨最小频差”。实际分辨率仍由窗的频域主瓣宽度决定，通常是若干个 bin 的量级。例如矩形窗的第一零点主瓣宽度约为 $2\Delta f$，Hann 窗约为 $4\Delta f$（按第一零点间距计），因此当 $\Delta f$ 固定后，不同窗函数会以常数倍方式改变真实分辨率与谱泄漏水平。

时间方向的离散化则由 hop 决定：`ShortTimeFFT` 的时间步进为

$$
\Delta t=\frac{\text{hop}}{F_s}.
$$

实现中令 `hop = m_win - int(xi*m_win)`，因此重叠比例约为 $\xi$，而

$$
\Delta t \approx \frac{(1-\xi)m_{\text{win}}}{F_s}\approx \frac{1-\xi}{\Delta f}.
$$

这给出一个清晰的量纲关系：在以 $\Delta f$ 固定频率网格的前提下，$\xi$ 控制时间采样密度与计算量；$\xi$ 越大，$\Delta t$ 越小，谱图时间方向更平滑，同时相邻切片相关性更强。

### 3.2 CWT 中 $\Delta f$ 的设定原理：频率轴采样与小波带宽的耦合

CWT 的自变量天然是尺度 $a$，但工程解释往往以物理频率 $f$ 为主，因此需要把“目标频率轴”反推到尺度轴。实现中首先构造线性频率网格

$$
f_k = f_1 + k\,\Delta f,\qquad k=0,1,\dots
$$

（代码为 `freqs = np.arange(f1, f2 + Df, Df)`），此处 $\Delta f$ 直接定义了尺度图沿频率方向的采样间隔。随后利用 PyWavelets 的伪频率关系将每个频率点映射为尺度：

$$
f \approx \frac{f_c}{a\,T}\quad \Longrightarrow\quad a(f)=\frac{f_c}{f\,T}=\frac{f_c}{f\,dt},
$$

其中 $f_c$ 为所选小波的中心频率（由 `pywt.central_frequency` 给出），$dt=1/F_s$。实现采用 `scales = fc / (freqs * dt)`，使得 `pywt.cwt` 的输出频率 `frequencies` 与所需频率轴保持一致的量纲与顺序。

仅有频率网格仍不足以保证“有效分辨率”与 $\Delta f$ 相称，因为 CWT 的分辨率由小波在频域的有效带宽决定。以复 Morlet 小波 `cmorB-C` 为例，其母小波包络为高斯型，参数 $B$ 控制时域扩展，从而反向控制频域带宽。可用近似关系概括为：母小波在频域的标准差与 $B$ 满足

$$
\sigma_f \propto \frac{1}{\sqrt{B}},
$$

而尺度变换会将频域带宽按 $1/a$ 缩放：

$$
\sigma_f(a)\approx \frac{\sigma_f(1)}{a}.
$$

当把尺度 $a(f)=f_c/(f\,dt)$ 代入时，得到

$$
\sigma_f(f)\ \propto\ \frac{f}{\sqrt{B}},
$$

这体现了 CWT 近似“常数相对带宽（constant-Q）”的性质：频率越高，绝对带宽越大。实现中取参考频率

$$
f_{\mathrm{ref}}=\sqrt{f_1f_2},
$$

并用

$$
B=\left(\frac{f_{\mathrm{ref}}}{\Delta f}\right)^2
$$

（代码为 `B = (f_ref / Df)**2`）设定小波参数，使得在参考频率附近有

$$
\sigma_f(f_{\mathrm{ref}})\ \propto\ \frac{f_{\mathrm{ref}}}{\sqrt{B}}\ \approx\ \Delta f,
$$

即把小波的有效带宽在频带中心处调到与频率网格间隔同一量级。这样一来，$\Delta f$ 同时控制了“频率轴采样密度”与“分析核带宽尺度”，减少了相邻频率行严重冗余（过采样）或显著跳变（欠采样）的风险。需要强调的是，该推导刻画的是量级匹配；比例常数与所用中心频率参数 $C$（实现中固定 `C=1.0`）以及 PyWavelets 对 `central_frequency` 的定义有关，因此更适合作为稳健的工程标定法则，而非严格等式。

### 3.3 STFT 窗函数的选取：在固定 $\Delta f$ 下的分辨率—泄漏折中

当 $m_{\text{win}}\approx F_s/\Delta f$ 已由目标 $\Delta f$ 锁定后，窗函数的选择主要影响两件事：频域主瓣宽度（决定实际分辨率常数倍）与旁瓣衰减（决定谱泄漏）。实现提供了三类代表性窗：

Hann 窗作为默认选项，通常在主瓣宽度与旁瓣抑制之间给出均衡折中。若以第一零点主瓣宽度衡量，Hann 窗的主瓣宽度约为 $4F_s/m_{\text{win}}\approx 4\Delta f$，旁瓣相对矩形窗显著降低，因此在一般振荡分量分析、噪声背景下的谱估计中具有良好的稳健性。

高斯窗分支通过把 $\Delta f$ 直接映射到高斯窗的时域标准差来实现更“解析”的参数标定。连续时间高斯包络 $g(t)=\exp\!\left(-t^2/(2\sigma_t^2)\right)$ 的傅里叶变换仍为高斯，其频域标准差满足 $\sigma_f = 1/(2\pi\sigma_t)$。实现取

$$
\text{std}=\frac{F_s}{2\pi\Delta f}\quad \Longrightarrow\quad \sigma_t=\frac{\text{std}}{F_s}=\frac{1}{2\pi\Delta f},
$$

于是 $\sigma_f=\Delta f$。在该标定下，$\Delta f$ 与频域“1-$\sigma$”宽度直接对应，因而在 chirp 等平滑时变频率结构的追踪中常呈现更平滑、伪影更少的时频能量脊线。窗长取 `win_len ≈ 6·std` 相当于覆盖 $\pm 3\sigma_t$ 的主要能量支撑；`hop ≈ std/2` 使相邻切片在高斯包络下保持较密的时间采样与较强的重叠一致性。

DPSS（Slepian）窗分支则以频带能量集中性为优势。DPSS 的参数 $NW$ 为时间—带宽积，若窗长为 $N=m_{\text{win}}$，则归一化半带宽 $W\approx NW/N$（单位：cycles/sample），对应到 Hz 的全带宽约为

$$
\text{BW}\approx 2W F_s \approx 2\,\frac{NW}{N}F_s \approx 2\,NW\,\Delta f.
$$

实现固定 `NW=2.5`，意味着在给定 $\Delta f$ 后，频域主能量大致集中在约 $5\Delta f$ 的带宽内，同时旁瓣与带外泄漏受控，适用于对谱泄漏更敏感、且希望把能量更集中地限制在某一频带邻域的应用场景。

## 4 去趋势与对数扫频的亮度补偿

短时傅里叶变换在工程应用中往往不直接对原始序列作时频映射，而是先进行若干与“可解释性”和“动态范围”相关的处理。其中两项操作尤为常见：其一是去趋势（detrending），其二是在对数扫频（log-chirp）场景下为谱图显示进行“亮度补偿”。

### 4.1 去趋势

将离散信号分解为“缓变基线 + 零均值波动”是理解去趋势的直接入口。设输入为 $x[n]$，写成

$$
x[n]=m[n]+\tilde{x}[n],
$$

其中 $m[n]$ 表示缓慢变化的趋势项（最简单情形为常数均值 $m$），$\tilde{x}[n]$ 为围绕零均值振荡的成分。STFT 在第 $p$ 个时间切片上的离散形式可写为

$$
X_p[k]=\sum_{n} x[n]\,w[n-pH]\,e^{-j2\pi kn/M},
$$

这里 $w[\cdot]$ 为窗函数，$H$ 为 hop，$M$ 为 FFT 长度。将分解代入可得

$$
X_p[k]=\underbrace{\sum_{n} \tilde{x}[n]\,w[n-pH]\,e^{-j2\pi kn/M}}_{\tilde{X}_p[k]}
+\underbrace{\sum_{n} m[n]\,w[n-pH]\,e^{-j2\pi kn/M}}_{M_p[k]}.
$$

当趋势项近似为常数 $m[n]\approx m$ 时，第二项简化为

$$
M_p[k]\approx m\sum_{n} w[n-pH]\,e^{-j2\pi kn/M}=m\,W[k]\,e^{-j2\pi k(pH)/M},
$$

其中 $W[k]$ 是窗函数的离散频谱（相位因子来自平移）。这一定量表达揭示了去趋势的核心动机：均值项会以窗函数频谱 $W[k]$ 的形状注入到每个时间切片中。由于大多数窗的频谱在 $k=0$ 附近幅值最大，均值会产生强 DC 分量；同时 $W[k]$ 并非理想冲激，而具有主瓣与旁瓣结构，于是 DC 能量会通过旁瓣“泄漏”到非零频率，引发低频带整体抬升，进而压缩谱图动态范围，掩盖弱的调制或瞬态结构。若趋势项是缓慢变化的 $m[n]$，其能量本质上仍集中在低频附近，同样会与窗频谱卷积后在谱图低频区域形成宽范围污染。

去趋势的实施方式可分为“全局去趋势”和“分段去趋势”两种常用范式。全局去趋势将整段序列的均值（或线性趋势）一次性移除，典型做法是

$$
x_{\text{in}}[n]=x[n]-\bar{x},
$$

从而避免在所有时间切片中反复出现由 $\bar{x}$ 引起的 DC 注入。对应实现可直接调用常数型去趋势，例如 `signal.detrend(data, type='constant')`。分段去趋势则更贴近 STFT 的分段本质：在每个窗段内部估计并移除该段的常值或线性趋势，数学上等价于对每个 $p$ 单独构造

$$
x_p[n]=x[n]w[n-pH]-\mu_p\,w[n-pH],
$$

其中 $\mu_p$ 是第 $p$ 段的局部均值（或更一般的局部趋势拟合）。这一策略对存在缓慢漂移、工况变化或段间基线不一致的信号更为稳健，因为它抑制的是“每段窗内的低频偏置”，而非仅抑制全局均值。对应实现常见于专门的 STFT 接口，例如以 `stft_detrend(..., detr='constant')` 在每段内部执行常值去趋势。上述两种方式在代码层面的差异也恰好体现为：先对原始序列去趋势再做 `stft`，或直接在 STFT 计算内部对每段去趋势后再做 FFT。

### 4.2 对数扫频的亮度补偿

对数扫频信号通常指瞬时频率按指数规律变化的 chirp。设连续时间瞬时频率为

$$
f(t)=f_1\left(\frac{f_2}{f_1}\right)^{t/T},
\quad t\in[0,T],
$$

其对数频率随时间线性增长：

$$
\frac{d}{dt}\ln f(t)=\frac{1}{T}\ln\!\left(\frac{f_2}{f_1}\right)=\kappa,
$$

因此

$$
dt=\frac{1}{\kappa}\,d(\ln f)=\frac{1}{\kappa}\frac{df}{f}.
$$

该关系具有直接的谱学含义：在对数扫频中，相同的对数频率区间 $d(\ln f)$ 对应相同的时间驻留 $dt$；而在“线性频率”度量下，每 1 Hz 的驻留时间随频率按 $1/f$ 衰减。若扫频的瞬时幅度近似恒定，则单位时间能量输入近似恒定，于是分配到单位频率宽度 $df$ 上的能量（或功率密度意义下的谱强度）将呈现

$$
P(f)\propto \frac{dt}{df}\propto \frac{1}{f}.
$$

这就解释了对数扫频在以“每 Hz”为密度含义的谱量（例如 PSD 或与 PSD 成比例的谱图强度）上天然带有 $-1$ 的斜率：低频段由于驻留时间更长而更“亮”，高频段更“暗”。

<img src="/fig/log_chirp_psd.png" alt="对数扫频功率谱" width="70%">

若谱图的显示坐标使用对数频率轴（log-frequency axis），视觉期望往往是“相同对数频率宽度上亮度可比”，也就是希望展示的是“每 $d(\ln f)$”上的能量密度，而非“每 $df$”上的能量密度。密度在变量变换下满足

$$
P_{\ln}(f)\,d(\ln f)=P(f)\,df,
$$

代入 $d(\ln f)=df/f$ 得到

$$
P_{\ln}(f)=f\,P(f).
$$

因此，若 $P(f)$ 近似呈 $1/f$ 规律，则 $P_{\ln}(f)$ 近似为常数；从显示角度看，把谱量乘以 $f$ 会将对数扫频的“固有倾斜”拉平。

这一思想与 STFT 幅度图的实现衔接非常直接。设 STFT 复系数为 $S(f,t)$，常见的“能量/功率型”谱图取 $|S(f,t)|^2$（与窗归一化方式相关时可近似对应局部 PSD）。若显示目标是 $f,|S(f,t)|^2$，则对“幅度型”谱图 $|S|$ 的等价操作为乘以 $\sqrt{f}$，因为

$$
\left(\sqrt{f}\,|S|\right)^2=f\,|S|^2.
$$

这正对应实现中“亮度补偿”的写法：在计算 $|\text{stft}|$ 后按频率行乘以 $\sqrt{f}$，即 `S = S * np.sqrt(sft.f[:, None])`。同样的补偿也出现在小波系数幅度上，例如 `S_plot = S * np.sqrt(frequencies[:, None])`，只是此处不展开讨论。

从另一个角度看，该补偿也可理解为“将线性频率谱密度转换为对数频率谱密度”。当横轴取 $\log f$ 时，若仍以 $|S|^2$ 直接着色，相当于在对数坐标下仍显示“每 Hz”的密度，视觉上自然产生系统性倾斜；而用 $f|S|^2$ 着色则是在同一坐标下显示“每对数频率”的密度，更契合对数轴下等宽像素对应等比例频带的几何意义。

## 5 基于 STFT 输出的谱图绘制

完成 STFT 计算、去趋势与亮度补偿之后，时频结果通常以二维矩阵形式进入可视化阶段。以 `ShortTimeFFT` 的输出为例，`stft_analysis` 返回的 `S` 是按频率行、时间列排列的幅度矩阵（或经补偿后的幅度矩阵），而 `extent` 提供了与该矩阵一致的物理坐标范围。绘图的关键在于：确保矩阵索引方向与物理坐标轴一致，确保频率轴的对数映射与色标含义一致，并显式处理边界效应与动态范围，以避免视觉上产生可被误解的结构。

在 Matplotlib 中，`imshow` 默认把矩阵的第 0 行画在图像上方，而时频谱图通常希望“低频在下、高频在上”。因此常用 `origin="lower"` 将第 0 行放在图像底部，与 `ShortTimeFFT` 输出频率数组 `sft.f` 从低到高的顺序一致。与此同时，`extent` 将像素坐标映射到物理坐标，典型形式为 $[t_{\min}, t_{\max}, f_{\min}, f_{\max}]$，并与 `imshow` 的横纵轴范围同步，使得每一个像素块对应具体的时间—频率矩形区域。由于 `extent` 由 `sft.extent(n)` 直接生成，且内部已考虑窗在两端造成的时间扩展，绘图时出现信号起止之外的时间区间是正常现象；若需要在图中强调有效信号区间，可进一步叠加竖线标注 $t=0$ 与 $t=n/F_s$，或用半透明阴影标示窗未完全落入信号范围的边缘带，但这属于展示选择而非必须步骤。

频率轴的对数显示通常通过 `plt.yscale("log")` 完成，此时 `extent` 的频率上下限必须为正数，且 `ylim` 需避开 0。对数扫频等宽带跨度较大的场景中，对数频轴能更直观地展示频率随时间的比例变化，并与前述“亮度补偿”形成一致的度量体系。示例中使用 `plt.ylim((0.001, 0.01))` 等价于将关注频带裁剪到 $[1\,\mathrm{mHz}, 10\,\mathrm{mHz}]$，这一裁剪不仅提升可读性，也能减少色标被无关频段主导的风险。若频带裁剪发生在绘图阶段而非计算阶段，矩阵仍包含全频信息，但显示只取其中一部分；这与后续需要做定量分析时“保留全矩阵”并不冲突。

`aspect="auto"` 常用于谱图绘制，原因是时间与频率轴的物理单位不同，且时间跨度与频带跨度可能相差数个量级，强行设为等比例会使图像过度拉伸，难以辨认结构。`imshow` 的插值在不同 Matplotlib 版本中可能有默认行为差异；若频率或时间采样较稀，插值可能造成平滑的视觉错觉，尤其在对数频轴下更明显。为保证“所见即所算”，可以将插值显式设为最近邻或无插值风格（例如 `interpolation="nearest"` 或 `interpolation="none"`），从而使每个像素块对应一个真实的 STFT 栅格单元；是否采用由展示偏好与分辨率情况共同决定。

色标的含义取决于 `S` 的定义。示例中 `S` 来自 `np.abs(sft.stft(...))` 并乘以 $\sqrt{f}$ 做亮度补偿，因此色标反映的是“幅度型量的补偿结果”，其平方与 $f|S|^2$ 成比例，更接近对数频率度量下的功率密度展示。在动态范围很大的情况下，线性色标往往导致弱结构不可见，此时可以对显示量做对数压缩，例如绘制 $\log_{10}(S+\epsilon)$ 或 $\mathrm{dB}$ 标度（$20\log_{10}S$ 对幅度、$10\log_{10}$ 对功率），其中 $\epsilon$ 用于避免对数的数值问题；不过一旦做对数压缩，色标单位与解释也随之改变，需要在图例或色条标签中体现。即便保持线性色标，`plt.colorbar(im)` 也应被视为必需的定量参照，因为谱图中的“亮/暗”并不具有绝对含义，只有在色条的映射下才可比较不同图或不同区域的强度。

综合上述要点，一种紧凑且物理一致的绘图流程可概括为：使用 `imshow` 直接绘制 `S`，用 `origin="lower"` 保证频率方向符合直觉，用 `extent` 完成时间—频率物理坐标映射，用 `yscale("log")` 与 `ylim` 聚焦目标频带，并通过 `colorbar` 固化强度参照。示例代码中的核心片段正对应这一流程：先计算得到 `sft_out['S']` 与 `sft_out['extent']`，再以 `imshow(..., extent=..., origin="lower", aspect="auto")` 显示，并配合对数频轴与频带裁剪完成最终谱图呈现。